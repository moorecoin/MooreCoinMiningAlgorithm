code-signing private key notes
==

the private keys for these certificates were generated on gavin's main work machine,
following the certificate authoritys' recommendations for generating certificate
signing requests.

for osx, the private key was generated by keychain.app on gavin's main work machine.
the key and certificate is in a separate, passphrase-protected keychain file that is
unlocked to sign the bitcoin-qt.app bundle.

for windows, the private key was generated by firefox running on gavin's main work machine.
the key and certificate were exported into a separate, passphrase-protected pkcs#12 file, and
then deleted from firefox's keystore. the exported file is used to sign the windows setup.exe.

threat analysis
--

gavin is a single point of failure. he could be coerced to divulge the secret signing keys,
allowing somebody to distribute a bitcoin-qt.app or bitcoin-qt-setup.exe with a valid
signature but containing a malicious binary.

or the machine gavin uses to sign the binaries could be compromised, either remotely or
by breaking in to his office, allowing the attacker to get the private key files and then
install a keylogger to get the passphrase that protects them.

threat mitigation
--

"air gapping" the machine used to do the signing will not work, because the signing
process needs to access a timestamp server over the network. and it would not
prevent the "rubber hose cryptography" threat (coercing gavin to sign a bad binary
or divulge the private keys).

windows binaries are reproducibly 'gitian-built', and the setup.exe file created
by the nsis installer system is a 7zip archive, so you could check to make sure
that the bitcoin-qt.exe file inside the installer had not been tampered with.
however, an attacker could modify the installer's code, so when the setup.exe
was run it compromised users' systems. a volunteer to write an auditing tool
that checks the setup.exe for tampering, and checks the files in it against
the list of gitian signatures, is needed.

the long-term solution is something like the 'gitian downloader' system, which
uses signatures from multiple developers to determine whether or not a binary
should be trusted. however, that just pushes the problem to "how will
non-technical users securely get the gitian downloader code to start?"
